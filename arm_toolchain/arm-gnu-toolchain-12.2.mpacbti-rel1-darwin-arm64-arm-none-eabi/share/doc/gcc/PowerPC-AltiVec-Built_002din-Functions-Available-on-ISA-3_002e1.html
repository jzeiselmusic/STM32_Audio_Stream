<html lang="en">
<head>
<title>PowerPC AltiVec Built-in Functions Available on ISA 3.1 - Using the GNU Compiler Collection (GCC)</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="Using the GNU Compiler Collection (GCC)">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="PowerPC-AltiVec_002fVSX-Built_002din-Functions.html#PowerPC-AltiVec_002fVSX-Built_002din-Functions" title="PowerPC AltiVec/VSX Built-in Functions">
<link rel="prev" href="PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e0.html#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e0" title="PowerPC AltiVec Built-in Functions Available on ISA 3.0">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988-2022 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``Funding Free Software'', the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="PowerPC-AltiVec-Built-in-Functions-Available-on-ISA-3.1"></a>
<a name="PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e1"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e0.html#PowerPC-AltiVec-Built_002din-Functions-Available-on-ISA-3_002e0">PowerPC AltiVec Built-in Functions Available on ISA 3.0</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="PowerPC-AltiVec_002fVSX-Built_002din-Functions.html#PowerPC-AltiVec_002fVSX-Built_002din-Functions">PowerPC AltiVec/VSX Built-in Functions</a>
<hr>
</div>

<h5 class="subsubsection">6.60.23.5 PowerPC AltiVec Built-in Functions Available on ISA 3.1</h5>

<p>The following additional built-in functions are also available for the
PowerPC family of processors, starting with ISA 3.1 (<samp><span class="option">-mcpu=power10</span></samp>):

<pre class="smallexample"><br>vector unsigned long long int<br>
<br>vec_cfuge (vector unsigned long long int, vector unsigned long long int);<br>
</pre>
 <p>Perform a vector centrifuge operation, as if implemented by the
<code>vcfuged</code> instruction. 
<a name="index-vec_005fcfuge-5154"></a>
<pre class="smallexample"><br>vector unsigned long long int<br>
<br>vec_cntlzm (vector unsigned long long int, vector unsigned long long int);<br>
</pre>
 <p>Perform a vector count leading zeros under bit mask operation, as if
implemented by the <code>vclzdm</code> instruction. 
<a name="index-vec_005fcntlzm-5155"></a>
<pre class="smallexample"><br>vector unsigned long long int<br>
<br>vec_cnttzm (vector unsigned long long int, vector unsigned long long int);<br>
</pre>
 <p>Perform a vector count trailing zeros under bit mask operation, as if
implemented by the <code>vctzdm</code> instruction. 
<a name="index-vec_005fcnttzm-5156"></a>
<pre class="smallexample"><br>vector signed char<br>
<br>vec_clrl (vector signed char a, unsigned int n);<br>
<br>vector unsigned char<br>
<br>vec_clrl (vector unsigned char a, unsigned int n);<br>
</pre>
 <p>Clear the left-most <code>(16 - n)</code> bytes of vector argument <code>a</code>, as if
implemented by the <code>vclrlb</code> instruction on a big-endian target
and by the <code>vclrrb</code> instruction on a little-endian target.  A
value of <code>n</code> that is greater than 16 is treated as if it equaled 16. 
<a name="index-vec_005fclrl-5157"></a>
<pre class="smallexample"><br>vector signed char<br>
<br>vec_clrr (vector signed char a, unsigned int n);<br>
<br>vector unsigned char<br>
<br>vec_clrr (vector unsigned char a, unsigned int n);<br>
</pre>
 <p>Clear the right-most <code>(16 - n)</code> bytes of vector argument <code>a</code>, as if
implemented by the <code>vclrrb</code> instruction on a big-endian target
and by the <code>vclrlb</code> instruction on a little-endian target.  A
value of <code>n</code> that is greater than 16 is treated as if it equaled 16. 
<a name="index-vec_005fclrr-5158"></a>
<pre class="smallexample"><br>vector unsigned long long int<br>
<br>vec_gnb (vector unsigned __int128, const unsigned char);<br>
</pre>
 <p>Perform a 128-bit vector gather  operation, as if implemented by the
<code>vgnb</code> instruction.  The second argument must be a literal
integer value between 2 and 7 inclusive. 
<a name="index-vec_005fgnb-5159"></a>

 <p>Vector Extract

<pre class="smallexample"><br>vector unsigned long long int<br>
<br>vec_extractl (vector unsigned char, vector unsigned char, unsigned int);<br>
<br>vector unsigned long long int<br>
<br>vec_extractl (vector unsigned short, vector unsigned short, unsigned int);<br>
<br>vector unsigned long long int<br>
<br>vec_extractl (vector unsigned int, vector unsigned int, unsigned int);<br>
<br>vector unsigned long long int<br>
<br>vec_extractl (vector unsigned long long, vector unsigned long long, unsigned int);<br>
</pre>
 <p>Extract an element from two concatenated vectors starting at the given byte index
in natural-endian order, and place it zero-extended in doubleword 1 of the result
according to natural element order.  If the byte index is out of range for the
data type, the intrinsic will be rejected. 
For little-endian, this output will match the placement by the hardware
instruction, i.e., dword[0] in RTL notation.  For big-endian, an additional
instruction is needed to move it from the "left" doubleword to the  "right" one. 
For little-endian, semantics matching the <code>vextdubvrx</code>,
<code>vextduhvrx</code>, <code>vextduwvrx</code> instruction will be generated, while for
big-endian, semantics matching the <code>vextdubvlx</code>, <code>vextduhvlx</code>,
<code>vextduwvlx</code> instructions
will be generated.  Note that some fairly anomalous results can be generated if
the byte index is not aligned on an element boundary for the element being
extracted.  This is a limitation of the bi-endian vector programming model is
consistent with the limitation on <code>vec_perm</code>. 
<a name="index-vec_005fextractl-5160"></a>
<pre class="smallexample"><br>vector unsigned long long int<br>
<br>vec_extracth (vector unsigned char, vector unsigned char, unsigned int);<br>
<br>vector unsigned long long int<br>
<br>vec_extracth (vector unsigned short, vector unsigned short,<br>
     unsigned int);
<br>vector unsigned long long int<br>
<br>vec_extracth (vector unsigned int, vector unsigned int, unsigned int);<br>
<br>vector unsigned long long int<br>
<br>vec_extracth (vector unsigned long long, vector unsigned long long,<br>
     unsigned int);
</pre>
 <p>Extract an element from two concatenated vectors starting at the given byte
index.  The index is based on big endian order for a little endian system. 
Similarly, the index is based on little endian order for a big endian system. 
The extraced elements are zero-extended and put in doubleword 1
according to natural element order.  If the byte index is out of range for the
data type, the intrinsic will be rejected.  For little-endian, this output
will match the placement by the hardware instruction (vextdubvrx, vextduhvrx,
vextduwvrx, vextddvrx) i.e., dword[0] in RTL
notation.  For big-endian, an additional instruction is needed to move it
from the "left" doubleword to the "right" one.  For little-endian, semantics
matching the <code>vextdubvlx</code>, <code>vextduhvlx</code>, <code>vextduwvlx</code>
instructions will be generated, while for big-endian, semantics matching the
<code>vextdubvrx</code>, <code>vextduhvrx</code>, <code>vextduwvrx</code> instructions will
be generated.  Note that some fairly anomalous
results can be generated if the byte index is not aligned on the
element boundary for the element being extracted.  This is a
limitation of the bi-endian vector programming model consistent with the
limitation on <code>vec_perm</code>. 
<a name="index-vec_005fextracth-5161"></a>
<pre class="smallexample"><br>vector unsigned long long int<br>
<br>vec_pdep (vector unsigned long long int, vector unsigned long long int);<br>
</pre>
 <p>Perform a vector parallel bits deposit operation, as if implemented by
the <code>vpdepd</code> instruction. 
<a name="index-vec_005fpdep-5162"></a>
Vector Insert

<pre class="smallexample"><br>vector unsigned char<br>
<br>vec_insertl (unsigned char, vector unsigned char, unsigned int);<br>
<br>vector unsigned short<br>
<br>vec_insertl (unsigned short, vector unsigned short, unsigned int);<br>
<br>vector unsigned int<br>
<br>vec_insertl (unsigned int, vector unsigned int, unsigned int);<br>
<br>vector unsigned long long<br>
<br>vec_insertl (unsigned long long, vector unsigned long long,<br>
     unsigned int);
<br>vector unsigned char<br>
<br>vec_insertl (vector unsigned char, vector unsigned char, unsigned int;<br>
<br>vector unsigned short<br>
<br>vec_insertl (vector unsigned short, vector unsigned short,<br>
     unsigned int);
<br>vector unsigned int<br>
<br>vec_insertl (vector unsigned int, vector unsigned int, unsigned int);<br>
</pre>
 <p>Let src be the first argument, when the first argument is a scalar, or the
rightmost element of the left doubleword of the first argument, when the first
argument is a vector.  Insert the source into the destination at the position
given by the third argument, using natural element order in the second
argument.  The rest of the second argument is unchanged.  If the byte
index is greater than 14 for halfwords, greater than 12 for words, or
greater than 8 for doublewords the result is undefined.   For little-endian,
the generated code will be semantically equivalent to <code>vins[bhwd]rx</code>
instructions.  Similarly for big-endian it will be semantically equivalent
to <code>vins[bhwd]lx</code>.  Note that some fairly anomalous results can be
generated if the byte index is not aligned on an element boundary for the
type of element being inserted. 
<a name="index-vec_005finsertl-5163"></a>
<pre class="smallexample"><br>vector unsigned char<br>
<br>vec_inserth (unsigned char, vector unsigned char, unsigned int);<br>
<br>vector unsigned short<br>
<br>vec_inserth (unsigned short, vector unsigned short, unsigned int);<br>
<br>vector unsigned int<br>
<br>vec_inserth (unsigned int, vector unsigned int, unsigned int);<br>
<br>vector unsigned long long<br>
<br>vec_inserth (unsigned long long, vector unsigned long long,<br>
     unsigned int);
<br>vector unsigned char<br>
<br>vec_inserth (vector unsigned char, vector unsigned char, unsigned int);<br>
<br>vector unsigned short<br>
<br>vec_inserth (vector unsigned short, vector unsigned short,<br>
     unsigned int);
<br>vector unsigned int<br>
<br>vec_inserth (vector unsigned int, vector unsigned int, unsigned int);<br>
</pre>
 <p>Let src be the first argument, when the first argument is a scalar, or the
rightmost element of the first argument, when the first argument is a vector. 
Insert src into the second argument at the position identified by the third
argument, using opposite element order in the second argument, and leaving the
rest of the second argument unchanged.  If the byte index is greater than 14
for halfwords, 12 for words, or 8 for doublewords, the intrinsic will be
rejected. Note that the underlying hardware instruction uses the same register
for the second argument and the result. 
For little-endian, the code generation will be semantically equivalent to
<code>vins[bhwd]lx</code>, while for big-endian it will be semantically equivalent to
<code>vins[bhwd]rx</code>. 
Note that some fairly anomalous results can be generated if the byte index is
not aligned on an element boundary for the sort of element being inserted. 
<a name="index-vec_005finserth-5164"></a>
Vector Replace Element
<pre class="smallexample"><br>vector signed int vec_replace_elt (vector signed int, signed int,<br>
     const int);
<br>vector unsigned int vec_replace_elt (vector unsigned int,<br>
     unsigned int, const int);
<br>vector float vec_replace_elt (vector float, float, const int);<br>
<br>vector signed long long vec_replace_elt (vector signed long long,<br>
     signed long long, const int);
<br>vector unsigned long long vec_replace_elt (vector unsigned long long,<br>
     unsigned long long, const int);
<br>vector double rec_replace_elt (vector double, double, const int);<br>
</pre>
 <p>The third argument (constrained to [0,3]) identifies the natural-endian
element number of the first argument that will be replaced by the second
argument to produce the result.  The other elements of the first argument will
remain unchanged in the result.

 <p>If it's desirable to insert a word at an unaligned position, use
vec_replace_unaligned instead.

 <p><a name="index-vec_005freplace_005felement-5165"></a>
Vector Replace Unaligned
<pre class="smallexample"><br>vector unsigned char vec_replace_unaligned (vector unsigned char,<br>
     signed int, const int);
<br>vector unsigned char vec_replace_unaligned (vector unsigned char,<br>
     unsigned int, const int);
<br>vector unsigned char vec_replace_unaligned (vector unsigned char,<br>
     float, const int);
<br>vector unsigned char vec_replace_unaligned (vector unsigned char,<br>
     signed long long, const int);
<br>vector unsigned char vec_replace_unaligned (vector unsigned char,<br>
     unsigned long long, const int);
<br>vector unsigned char vec_replace_unaligned (vector unsigned char,<br>
     double, const int);
</pre>
 <p>The second argument replaces a portion of the first argument to produce the
result, with the rest of the first argument unchanged in the result.  The
third argument identifies the byte index (using left-to-right, or big-endian
order) where the high-order byte of the second argument will be placed, with
the remaining bytes of the second argument placed naturally "to the right"
of the high-order byte.

 <p>The programmer is responsible for understanding the endianness issues involved
with the first argument and the result. 
<a name="index-vec_005freplace_005funaligned-5166"></a>
Vector Shift Left Double Bit Immediate
<pre class="smallexample"><br>vector signed char vec_sldb (vector signed char, vector signed char,<br>
     const unsigned int);
<br>vector unsigned char vec_sldb (vector unsigned char,<br>
     vector unsigned char, const unsigned int);
<br>vector signed short vec_sldb (vector signed short, vector signed short,<br>
     const unsigned int);
<br>vector unsigned short vec_sldb (vector unsigned short,<br>
     vector unsigned short, const unsigned int);
<br>vector signed int vec_sldb (vector signed int, vector signed int,<br>
     const unsigned int);
<br>vector unsigned int vec_sldb (vector unsigned int, vector unsigned int,<br>
     const unsigned int);
<br>vector signed long long vec_sldb (vector signed long long,<br>
     vector signed long long, const unsigned int);
<br>vector unsigned long long vec_sldb (vector unsigned long long,<br>
     vector unsigned long long, const unsigned int);
</pre>
 <p>Shift the combined input vectors left by the amount specified by the low-order
three bits of the third argument, and return the leftmost remaining 128 bits. 
Code using this instruction must be endian-aware.

 <p><a name="index-vec_005fsldb-5167"></a>
Vector Shift Right Double Bit Immediate

<pre class="smallexample"><br>vector signed char vec_srdb (vector signed char, vector signed char,<br>
     const unsigned int);
<br>vector unsigned char vec_srdb (vector unsigned char, vector unsigned char,<br>
     const unsigned int);
<br>vector signed short vec_srdb (vector signed short, vector signed short,<br>
     const unsigned int);
<br>vector unsigned short vec_srdb (vector unsigned short, vector unsigned short,<br>
     const unsigned int);
<br>vector signed int vec_srdb (vector signed int, vector signed int,<br>
     const unsigned int);
<br>vector unsigned int vec_srdb (vector unsigned int, vector unsigned int,<br>
     const unsigned int);
<br>vector signed long long vec_srdb (vector signed long long,<br>
     vector signed long long, const unsigned int);
<br>vector unsigned long long vec_srdb (vector unsigned long long,<br>
     vector unsigned long long, const unsigned int);
</pre>
 <p>Shift the combined input vectors right by the amount specified by the low-order
three bits of the third argument, and return the remaining 128 bits.  Code
using this built-in must be endian-aware.

 <p><a name="index-vec_005fsrdb-5168"></a>
Vector Splat

<pre class="smallexample"><br>vector signed int vec_splati (const signed int);<br>
<br>vector float vec_splati (const float);<br>
</pre>
 <p>Splat a 32-bit immediate into a vector of words.

 <p><a name="index-vec_005fsplati-5169"></a>
<pre class="smallexample"><br>vector double vec_splatid (const float);<br>
</pre>
 <p>Convert a single precision floating-point value to double-precision and splat
the result to a vector of double-precision floats.

 <p><a name="index-vec_005fsplatid-5170"></a>
<pre class="smallexample"><br>vector signed int vec_splati_ins (vector signed int,<br>
     const unsigned int, const signed int);
<br>vector unsigned int vec_splati_ins (vector unsigned int,<br>
     const unsigned int, const unsigned int);
<br>vector float vec_splati_ins (vector float, const unsigned int,<br>
     const float);
</pre>
 <p>Argument 2 must be either 0 or 1.  Splat the value of argument 3 into the word
identified by argument 2 of each doubleword of argument 1 and return the
result.  The other words of argument 1 are unchanged.

 <p><a name="index-vec_005fsplati_005fins-5171"></a>
Vector Blend Variable

<pre class="smallexample"><br>vector signed char vec_blendv (vector signed char, vector signed char,<br>
     vector unsigned char);
<br>vector unsigned char vec_blendv (vector unsigned char,<br>
     vector unsigned char, vector unsigned char);
<br>vector signed short vec_blendv (vector signed short,<br>
     vector signed short, vector unsigned short);
<br>vector unsigned short vec_blendv (vector unsigned short,<br>
     vector unsigned short, vector unsigned short);
<br>vector signed int vec_blendv (vector signed int, vector signed int,<br>
     vector unsigned int);
<br>vector unsigned int vec_blendv (vector unsigned int,<br>
     vector unsigned int, vector unsigned int);
<br>vector signed long long vec_blendv (vector signed long long,<br>
     vector signed long long, vector unsigned long long);
<br>vector unsigned long long vec_blendv (vector unsigned long long,<br>
     vector unsigned long long, vector unsigned long long);
<br>vector float vec_blendv (vector float, vector float,<br>
     vector unsigned int);
<br>vector double vec_blendv (vector double, vector double,<br>
     vector unsigned long long);
</pre>
 <p>Blend the first and second argument vectors according to the sign bits of the
corresponding elements of the third argument vector.  This is similar to the
<code>vsel</code> and <code>xxsel</code> instructions but for bigger elements.

 <p><a name="index-vec_005fblendv-5172"></a>
Vector Permute Extended

<pre class="smallexample"><br>vector signed char vec_permx (vector signed char, vector signed char,<br>
     vector unsigned char, const int);
<br>vector unsigned char vec_permx (vector unsigned char,<br>
     vector unsigned char, vector unsigned char, const int);
<br>vector signed short vec_permx (vector signed short,<br>
     vector signed short, vector unsigned char, const int);
<br>vector unsigned short vec_permx (vector unsigned short,<br>
     vector unsigned short, vector unsigned char, const int);
<br>vector signed int vec_permx (vector signed int, vector signed int,<br>
     vector unsigned char, const int);
<br>vector unsigned int vec_permx (vector unsigned int,<br>
     vector unsigned int, vector unsigned char, const int);
<br>vector signed long long vec_permx (vector signed long long,<br>
     vector signed long long, vector unsigned char, const int);
<br>vector unsigned long long vec_permx (vector unsigned long long,<br>
     vector unsigned long long, vector unsigned char, const int);
<br>vector float (vector float, vector float, vector unsigned char,<br>
     const int);
<br>vector double (vector double, vector double, vector unsigned char,<br>
     const int);
</pre>
 <p>Perform a partial permute of the first two arguments, which form a 32-byte
section of an emulated vector up to 256 bytes wide, using the partial permute
control vector in the third argument.  The fourth argument (constrained to
values of 0-7) identifies which 32-byte section of the emulated vector is
contained in the first two arguments. 
<a name="index-vec_005fpermx-5173"></a>
<pre class="smallexample"><br>vector unsigned long long int<br>
<br>vec_pext (vector unsigned long long int, vector unsigned long long int);<br>
</pre>
 <p>Perform a vector parallel bit extract operation, as if implemented by
the <code>vpextd</code> instruction. 
<a name="index-vec_005fpext-5174"></a>
<pre class="smallexample"><br>vector unsigned char vec_stril (vector unsigned char);<br>
<br>vector signed char vec_stril (vector signed char);<br>
<br>vector unsigned short vec_stril (vector unsigned short);<br>
<br>vector signed short vec_stril (vector signed short);<br>
</pre>
 <p>Isolate the left-most non-zero elements of the incoming vector argument,
replacing all elements to the right of the left-most zero element
found within the argument with zero.  The typical implementation uses
the <code>vstribl</code> or <code>vstrihl</code> instruction on big-endian targets
and uses the <code>vstribr</code> or <code>vstrihr</code> instruction on
little-endian targets. 
<a name="index-vec_005fstril-5175"></a>
<pre class="smallexample"><br>int vec_stril_p (vector unsigned char);<br>
<br>int vec_stril_p (vector signed char);<br>
<br>int short vec_stril_p (vector unsigned short);<br>
<br>int vec_stril_p (vector signed short);<br>
</pre>
 <p>Return a non-zero value if and only if the argument contains a zero
element.  The typical implementation uses
the <code>vstribl.</code> or <code>vstrihl.</code> instruction on big-endian targets
and uses the <code>vstribr.</code> or <code>vstrihr.</code> instruction on
little-endian targets.  Choose this built-in to check for presence of
zero element if the same argument is also passed to <code>vec_stril</code>. 
<a name="index-vec_005fstril_005fp-5176"></a>
<pre class="smallexample"><br>vector unsigned char vec_strir (vector unsigned char);<br>
<br>vector signed char vec_strir (vector signed char);<br>
<br>vector unsigned short vec_strir (vector unsigned short);<br>
<br>vector signed short vec_strir (vector signed short);<br>
</pre>
 <p>Isolate the right-most non-zero elements of the incoming vector argument,
replacing all elements to the left of the right-most zero element
found within the argument with zero.  The typical implementation uses
the <code>vstribr</code> or <code>vstrihr</code> instruction on big-endian targets
and uses the <code>vstribl</code> or <code>vstrihl</code> instruction on
little-endian targets. 
<a name="index-vec_005fstrir-5177"></a>
<pre class="smallexample"><br>int vec_strir_p (vector unsigned char);<br>
<br>int vec_strir_p (vector signed char);<br>
<br>int short vec_strir_p (vector unsigned short);<br>
<br>int vec_strir_p (vector signed short);<br>
</pre>
 <p>Return a non-zero value if and only if the argument contains a zero
element.  The typical implementation uses
the <code>vstribr.</code> or <code>vstrihr.</code> instruction on big-endian targets
and uses the <code>vstribl.</code> or <code>vstrihl.</code> instruction on
little-endian targets.  Choose this built-in to check for presence of
zero element if the same argument is also passed to <code>vec_strir</code>. 
<a name="index-vec_005fstrir_005fp-5178"></a>
<pre class="smallexample"><br>vector unsigned char<br>
<br>vec_ternarylogic (vector unsigned char, vector unsigned char,<br>
                 vector unsigned char, const unsigned int);
<br>vector unsigned short<br>
<br>vec_ternarylogic (vector unsigned short, vector unsigned short,<br>
                 vector unsigned short, const unsigned int);
<br>vector unsigned int<br>
<br>vec_ternarylogic (vector unsigned int, vector unsigned int,<br>
                 vector unsigned int, const unsigned int);
<br>vector unsigned long long int<br>
<br>vec_ternarylogic (vector unsigned long long int, vector unsigned long long int,<br>
                 vector unsigned long long int, const unsigned int);
<br>vector unsigned __int128<br>
<br>vec_ternarylogic (vector unsigned __int128, vector unsigned __int128,<br>
                 vector unsigned __int128, const unsigned int);
</pre>
 <p>Perform a 128-bit vector evaluate operation, as if implemented by the
<code>xxeval</code> instruction.  The fourth argument must be a literal
integer value between 0 and 255 inclusive. 
<a name="index-vec_005fternarylogic-5179"></a>
<pre class="smallexample"><br>vector unsigned char vec_genpcvm (vector unsigned char, const int);<br>
<br>vector unsigned short vec_genpcvm (vector unsigned short, const int);<br>
<br>vector unsigned int vec_genpcvm (vector unsigned int, const int);<br>
<br>vector unsigned int vec_genpcvm (vector unsigned long long int,<br>
                                              const int);
</pre>
 <p>Vector Integer Multiply/Divide/Modulo

<pre class="smallexample"><br>vector signed int<br>
<br>vec_mulh (vector signed int a, vector signed int b);<br>
<br>vector unsigned int<br>
<br>vec_mulh (vector unsigned int a, vector unsigned int b);<br>
</pre>
 <p>For each integer value <code>i</code> from 0 to 3, do the following. The integer
value in word element <code>i</code> of a is multiplied by the integer value in word
element <code>i</code> of b. The high-order 32 bits of the 64-bit product are placed
into word element <code>i</code> of the vector returned.

<pre class="smallexample"><br>vector signed long long<br>
<br>vec_mulh (vector signed long long a, vector signed long long b);<br>
<br>vector unsigned long long<br>
<br>vec_mulh (vector unsigned long long a, vector unsigned long long b);<br>
</pre>
 <p>For each integer value <code>i</code> from 0 to 1, do the following. The integer
value in doubleword element <code>i</code> of a is multiplied by the integer value in
doubleword element <code>i</code> of b. The high-order 64 bits of the 128-bit product
are placed into doubleword element <code>i</code> of the vector returned.

<pre class="smallexample"><br>vector unsigned long long<br>
<br>vec_mul (vector unsigned long long a, vector unsigned long long b);<br>
<br>vector signed long long<br>
<br>vec_mul (vector signed long long a, vector signed long long b);<br>
</pre>
 <p>For each integer value <code>i</code> from 0 to 1, do the following. The integer
value in doubleword element <code>i</code> of a is multiplied by the integer value in
doubleword element <code>i</code> of b. The low-order 64 bits of the 128-bit product
are placed into doubleword element <code>i</code> of the vector returned.

<pre class="smallexample"><br>vector signed int<br>
<br>vec_div (vector signed int a, vector signed int b);<br>
<br>vector unsigned int<br>
<br>vec_div (vector unsigned int a, vector unsigned int b);<br>
</pre>
 <p>For each integer value <code>i</code> from 0 to 3, do the following. The integer in
word element <code>i</code> of a is divided by the integer in word element <code>i</code>
of b. The unique integer quotient is placed into the word element <code>i</code> of
the vector returned. If an attempt is made to perform any of the divisions
&lt;anything&gt; ÷ 0 then the quotient is undefined.

<pre class="smallexample"><br>vector signed long long<br>
<br>vec_div (vector signed long long a, vector signed long long b);<br>
<br>vector unsigned long long<br>
<br>vec_div (vector unsigned long long a, vector unsigned long long b);<br>
</pre>
 <p>For each integer value <code>i</code> from 0 to 1, do the following. The integer in
doubleword element <code>i</code> of a is divided by the integer in doubleword
element <code>i</code> of b. The unique integer quotient is placed into the
doubleword element <code>i</code> of the vector returned. If an attempt is made to
perform any of the divisions 0x8000_0000_0000_0000 ÷ -1 or &lt;anything&gt; ÷ 0 then
the quotient is undefined.

<pre class="smallexample"><br>vector signed int<br>
<br>vec_dive (vector signed int a, vector signed int b);<br>
<br>vector unsigned int<br>
<br>vec_dive (vector unsigned int a, vector unsigned int b);<br>
</pre>
 <p>For each integer value <code>i</code> from 0 to 3, do the following. The integer in
word element <code>i</code> of a is shifted left by 32 bits, then divided by the
integer in word element <code>i</code> of b. The unique integer quotient is placed
into the word element <code>i</code> of the vector returned. If the quotient cannot
be represented in 32 bits, or if an attempt is made to perform any of the
divisions &lt;anything&gt; ÷ 0 then the quotient is undefined.

<pre class="smallexample"><br>vector signed long long<br>
<br>vec_dive (vector signed long long a, vector signed long long b);<br>
<br>vector unsigned long long<br>
<br>vec_dive (vector unsigned long long a, vector unsigned long long b);<br>
</pre>
 <p>For each integer value <code>i</code> from 0 to 1, do the following. The integer in
doubleword element <code>i</code> of a is shifted left by 64 bits, then divided by
the integer in doubleword element <code>i</code> of b. The unique integer quotient is
placed into the doubleword element <code>i</code> of the vector returned. If the
quotient cannot be represented in 64 bits, or if an attempt is made to perform
&lt;anything&gt; ÷ 0 then the quotient is undefined.

<pre class="smallexample"><br>vector signed int<br>
<br>vec_mod (vector signed int a, vector signed int b);<br>
<br>vector unsigned int<br>
<br>vec_mod (vector unsigned int a, vector unsigned int b);<br>
</pre>
 <p>For each integer value <code>i</code> from 0 to 3, do the following. The integer in
word element <code>i</code> of a is divided by the integer in word element <code>i</code>
of b. The unique integer remainder is placed into the word element <code>i</code> of
the vector returned.  If an attempt is made to perform any of the divisions
0x8000_0000 ÷ -1 or &lt;anything&gt; ÷ 0 then the remainder is undefined.

<pre class="smallexample"><br>vector signed long long<br>
<br>vec_mod (vector signed long long a, vector signed long long b);<br>
<br>vector unsigned long long<br>
<br>vec_mod (vector unsigned long long a, vector unsigned long long b);<br>
</pre>
 <p>For each integer value <code>i</code> from 0 to 1, do the following. The integer in
doubleword element <code>i</code> of a is divided by the integer in doubleword
element <code>i</code> of b. The unique integer remainder is placed into the
doubleword element <code>i</code> of the vector returned. If an attempt is made to
perform &lt;anything&gt; ÷ 0 then the remainder is undefined.

 <p>Generate PCV from specified Mask size, as if implemented by the
<code>xxgenpcvbm</code>, <code>xxgenpcvhm</code>, <code>xxgenpcvwm</code> instructions, where
immediate value is either 0, 1, 2 or 3. 
<a name="index-vec_005fgenpcvm-5180"></a>
<pre class="smallexample"><br>vector unsigned __int128 vec_rl (vector unsigned __int128 A,<br>
                                              vector unsigned __int128 B);
<br>vector signed __int128 vec_rl (vector signed __int128 A,<br>
                                            vector unsigned __int128 B);
</pre>
 <p>Result value: Each element of R is obtained by rotating the corresponding element
of A left by the number of bits specified by the corresponding element of B.

<pre class="smallexample"><br>vector unsigned __int128 vec_rlmi (vector unsigned __int128,<br>
                                                vector unsigned __int128,
                                                vector unsigned __int128);
<br>vector signed __int128 vec_rlmi (vector signed __int128,<br>
                                              vector signed __int128,
                                              vector unsigned __int128);
</pre>
 <p>Returns the result of rotating the first input and inserting it under mask
into the second input.  The first bit in the mask, the last bit in the mask are
obtained from the two 7-bit fields bits [108:115] and bits [117:123]
respectively of the second input.  The shift is obtained from the third input
in the 7-bit field [125:131] where all bits counted from zero at the left.

<pre class="smallexample"><br>vector unsigned __int128 vec_rlnm (vector unsigned __int128,<br>
                                                vector unsigned __int128,
                                                vector unsigned __int128);
<br>vector signed __int128 vec_rlnm (vector signed __int128,<br>
                                              vector unsigned __int128,
                                              vector unsigned __int128);
</pre>
 <p>Returns the result of rotating the first input and ANDing it with a mask.  The
first bit in the mask and the last bit in the mask are obtained from the two
7-bit fields bits [117:123] and bits [125:131] respectively of the second
input.  The shift is obtained from the third input in the 7-bit field bits
[125:131] where all bits counted from zero at the left.

<pre class="smallexample"><br>vector unsigned __int128 vec_sl(vector unsigned __int128 A, vector unsigned __int128 B);<br>
<br>vector signed __int128 vec_sl(vector signed __int128 A, vector unsigned __int128 B);<br>
</pre>
 <p>Result value: Each element of R is obtained by shifting the corresponding element of
A left by the number of bits specified by the corresponding element of B.

<pre class="smallexample"><br>vector unsigned __int128 vec_sr(vector unsigned __int128 A, vector unsigned __int128 B);<br>
<br>vector signed __int128 vec_sr(vector signed __int128 A, vector unsigned __int128 B);<br>
</pre>
 <p>Result value: Each element of R is obtained by shifting the corresponding element of
A right by the number of bits specified by the corresponding element of B.

<pre class="smallexample"><br>vector unsigned __int128 vec_sra(vector unsigned __int128 A, vector unsigned __int128 B);<br>
<br>vector signed __int128 vec_sra(vector signed __int128 A, vector unsigned __int128 B);<br>
</pre>
 <p>Result value: Each element of R is obtained by arithmetic shifting the corresponding
element of A right by the number of bits specified by the corresponding element of B.

<pre class="smallexample"><br>vector unsigned __int128 vec_mule (vector unsigned long long,<br>
                                                vector unsigned long long);
<br>vector signed __int128 vec_mule (vector signed long long,<br>
                                              vector signed long long);
</pre>
 <p>Returns a vector containing a 128-bit integer result of multiplying the even
doubleword elements of the two inputs.

<pre class="smallexample"><br>vector unsigned __int128 vec_mulo (vector unsigned long long,<br>
                                                vector unsigned long long);
<br>vector signed __int128 vec_mulo (vector signed long long,<br>
                                              vector signed long long);
</pre>
 <p>Returns a vector containing a 128-bit integer result of multiplying the odd
doubleword elements of the two inputs.

<pre class="smallexample"><br>vector unsigned __int128 vec_div (vector unsigned __int128,<br>
                                               vector unsigned __int128);
<br>vector signed __int128 vec_div (vector signed __int128,<br>
                                             vector signed __int128);
</pre>
 <p>Returns the result of dividing the first operand by the second operand. An
attempt to divide any value by zero or to divide the most negative signed
128-bit integer by negative one results in an undefined value.

<pre class="smallexample"><br>vector unsigned __int128 vec_dive (vector unsigned __int128,<br>
                                                vector unsigned __int128);
<br>vector signed __int128 vec_dive (vector signed __int128,<br>
                                              vector signed __int128);
</pre>
 <p>The result is produced by shifting the first input left by 128 bits and
dividing by the second.  If an attempt is made to divide by zero or the result
is larger than 128 bits, the result is undefined.

<pre class="smallexample"><br>vector unsigned __int128 vec_mod (vector unsigned __int128,<br>
                                               vector unsigned __int128);
<br>vector signed __int128 vec_mod (vector signed __int128,<br>
                                             vector signed __int128);
</pre>
 <p>The result is the modulo result of dividing the first input  by the second
input.

 <p>The following builtins perform 128-bit vector comparisons.  The
<code>vec_all_xx</code>, <code>vec_any_xx</code>, and <code>vec_cmpxx</code>, where <code>xx</code> is
one of the operations <code>eq, ne, gt, lt, ge, le</code> perform pairwise
comparisons between the elements at the same positions within their two vector
arguments.  The <code>vec_all_xx</code>function returns a non-zero value if and only
if all pairwise comparisons are true.  The <code>vec_any_xx</code> function returns
a non-zero value if and only if at least one pairwise comparison is true.  The
<code>vec_cmpxx</code>function returns a vector of the same type as its two
arguments, within which each element consists of all ones to denote that
specified logical comparison of the corresponding elements was true. 
Otherwise, the element of the returned vector contains all zeros.

<pre class="smallexample">     vector bool __int128 vec_cmpeq (vector signed __int128, vector signed __int128);
     vector bool __int128 vec_cmpeq (vector unsigned __int128, vector unsigned __int128);
     vector bool __int128 vec_cmpne (vector signed __int128, vector signed __int128);
     vector bool __int128 vec_cmpne (vector unsigned __int128, vector unsigned __int128);
     vector bool __int128 vec_cmpgt (vector signed __int128, vector signed __int128);
     vector bool __int128 vec_cmpgt (vector unsigned __int128, vector unsigned __int128);
     vector bool __int128 vec_cmplt (vector signed __int128, vector signed __int128);
     vector bool __int128 vec_cmplt (vector unsigned __int128, vector unsigned __int128);
     vector bool __int128 vec_cmpge (vector signed __int128, vector signed __int128);
     vector bool __int128 vec_cmpge (vector unsigned __int128, vector unsigned __int128);
     vector bool __int128 vec_cmple (vector signed __int128, vector signed __int128);
     vector bool __int128 vec_cmple (vector unsigned __int128, vector unsigned __int128);
     
     int vec_all_eq (vector signed __int128, vector signed __int128);
     int vec_all_eq (vector unsigned __int128, vector unsigned __int128);
     int vec_all_ne (vector signed __int128, vector signed __int128);
     int vec_all_ne (vector unsigned __int128, vector unsigned __int128);
     int vec_all_gt (vector signed __int128, vector signed __int128);
     int vec_all_gt (vector unsigned __int128, vector unsigned __int128);
     int vec_all_lt (vector signed __int128, vector signed __int128);
     int vec_all_lt (vector unsigned __int128, vector unsigned __int128);
     int vec_all_ge (vector signed __int128, vector signed __int128);
     int vec_all_ge (vector unsigned __int128, vector unsigned __int128);
     int vec_all_le (vector signed __int128, vector signed __int128);
     int vec_all_le (vector unsigned __int128, vector unsigned __int128);
     
     int vec_any_eq (vector signed __int128, vector signed __int128);
     int vec_any_eq (vector unsigned __int128, vector unsigned __int128);
     int vec_any_ne (vector signed __int128, vector signed __int128);
     int vec_any_ne (vector unsigned __int128, vector unsigned __int128);
     int vec_any_gt (vector signed __int128, vector signed __int128);
     int vec_any_gt (vector unsigned __int128, vector unsigned __int128);
     int vec_any_lt (vector signed __int128, vector signed __int128);
     int vec_any_lt (vector unsigned __int128, vector unsigned __int128);
     int vec_any_ge (vector signed __int128, vector signed __int128);
     int vec_any_ge (vector unsigned __int128, vector unsigned __int128);
     int vec_any_le (vector signed __int128, vector signed __int128);
     int vec_any_le (vector unsigned __int128, vector unsigned __int128);
</pre>
 </body></html>

