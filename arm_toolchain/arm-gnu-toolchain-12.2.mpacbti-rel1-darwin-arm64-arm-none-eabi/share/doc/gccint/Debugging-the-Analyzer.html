<html lang="en">
<head>
<title>Debugging the Analyzer - GNU Compiler Collection (GCC) Internals</title>
<meta http-equiv="Content-Type" content="text/html">
<meta name="description" content="GNU Compiler Collection (GCC) Internals">
<meta name="generator" content="makeinfo 4.8">
<link title="Top" rel="start" href="index.html#Top">
<link rel="up" href="Static-Analyzer.html#Static-Analyzer" title="Static Analyzer">
<link rel="prev" href="Analyzer-Internals.html#Analyzer-Internals" title="Analyzer Internals">
<link href="http://www.gnu.org/software/texinfo/" rel="generator-home" title="Texinfo Homepage">
<!--
Copyright (C) 1988-2022 Free Software Foundation, Inc.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with the
Invariant Sections being ``Funding Free Software'', the Front-Cover
Texts being (a) (see below), and with the Back-Cover Texts being (b)
(see below).  A copy of the license is included in the section entitled
``GNU Free Documentation License''.

(a) The FSF's Front-Cover Text is:

     A GNU Manual

(b) The FSF's Back-Cover Text is:

     You have freedom to copy and modify this GNU Manual, like GNU
     software.  Copies published by the Free Software Foundation raise
     funds for GNU development.-->
<meta http-equiv="Content-Style-Type" content="text/css">
<style type="text/css"><!--
  pre.display { font-family:inherit }
  pre.format  { font-family:inherit }
  pre.smalldisplay { font-family:inherit; font-size:smaller }
  pre.smallformat  { font-family:inherit; font-size:smaller }
  pre.smallexample { font-size:smaller }
  pre.smalllisp    { font-size:smaller }
  span.sc    { font-variant:small-caps }
  span.roman { font-family:serif; font-weight:normal; } 
  span.sansserif { font-family:sans-serif; font-weight:normal; } 
--></style>
</head>
<body>
<div class="node">
<p>
<a name="Debugging-the-Analyzer"></a>
Previous:&nbsp;<a rel="previous" accesskey="p" href="Analyzer-Internals.html#Analyzer-Internals">Analyzer Internals</a>,
Up:&nbsp;<a rel="up" accesskey="u" href="Static-Analyzer.html#Static-Analyzer">Static Analyzer</a>
<hr>
</div>

<h3 class="section">27.2 Debugging the Analyzer</h3>

<p><a name="index-analyzer_002c-debugging-5420"></a><a name="index-static-analyzer_002c-debugging-5421"></a>

<h4 class="subsection">27.2.1 Special Functions for Debugging the Analyzer</h4>

<p>The analyzer recognizes various special functions by name, for use
in debugging the analyzer.  Declarations can be seen in the testsuite
in <samp><span class="file">analyzer-decls.h</span></samp>.  None of these functions are actually
implemented.

 <p>Add:
<pre class="smallexample">       __analyzer_break ();
</pre>
 <p>to the source being analyzed to trigger a breakpoint in the analyzer when
that source is reached.  By putting a series of these in the source, it's
much easier to effectively step through the program state as it's analyzed.

 <p>The analyzer handles:

<pre class="smallexample">     __analyzer_describe (0, expr);
</pre>
 <p>by emitting a warning describing the 2nd argument (which can be of any
type), at a verbosity level given by the 1st argument.  This is for use when
debugging, and may be of use in DejaGnu tests.

<pre class="smallexample">     __analyzer_dump ();
</pre>
 <p>will dump the copious information about the analyzer's state each time it
reaches the call in its traversal of the source.

<pre class="smallexample">     extern void __analyzer_dump_capacity (const void *ptr);
</pre>
 <p>will emit a warning describing the capacity of the base region of
the region pointed to by the 1st argument.

<pre class="smallexample">     extern void __analyzer_dump_escaped (void);
</pre>
 <p>will emit a warning giving the number of decls that have escaped on this
analysis path, followed by a comma-separated list of their names,
in alphabetical order.

<pre class="smallexample">     __analyzer_dump_path ();
</pre>
 <p>will emit a placeholder &ldquo;note&rdquo; diagnostic with a path to that call site,
if the analyzer finds a feasible path to it.

 <p>The builtin <code>__analyzer_dump_exploded_nodes</code> will emit a warning
after analysis containing information on all of the exploded nodes at that
program point:

<pre class="smallexample">       __analyzer_dump_exploded_nodes (0);
</pre>
 <p>will output the number of &ldquo;processed&rdquo; nodes, and the IDs of
both &ldquo;processed&rdquo; and &ldquo;merger&rdquo; nodes, such as:

<pre class="smallexample">     warning: 2 processed enodes: [EN: 56, EN: 58] merger(s): [EN: 54-55, EN: 57, EN: 59]
</pre>
 <p>With a non-zero argument

<pre class="smallexample">       __analyzer_dump_exploded_nodes (1);
</pre>
 <p>it will also dump all of the states within the &ldquo;processed&rdquo; nodes.

<pre class="smallexample">        __analyzer_dump_region_model ();
</pre>
 <p>will dump the region_model's state to stderr.

<pre class="smallexample">     __analyzer_dump_state ("malloc", ptr);
</pre>
 <p>will emit a warning describing the state of the 2nd argument
(which can be of any type) with respect to the state machine with
a name matching the 1st argument (which must be a string literal). 
This is for use when debugging, and may be of use in DejaGnu tests.

<pre class="smallexample">     __analyzer_eval (expr);
</pre>
 <p>will emit a warning with text "TRUE", FALSE" or "UNKNOWN" based on the
truthfulness of the argument.  This is useful for writing DejaGnu tests.

<h4 class="subsection">27.2.2 Other Debugging Techniques</h4>

<p>The option <samp><span class="option">-fdump-analyzer-json</span></samp> will dump both the supergraph
and the exploded graph in compressed JSON form.

 <p>One approach when tracking down where a particular bogus state is
introduced into the <code>exploded_graph</code> is to add custom code to
<code>program_state::validate</code>.

 <p>The debug function <code>region::is_named_decl_p</code> can be used when debugging,
such as for assertions and conditional breakpoints.  For example, when
tracking down a bug in handling a decl called <code>yy_buffer_stack</code>, I
temporarily added a:
<pre class="smallexample">       gcc_assert (!m_base_region-&gt;is_named_decl_p ("yy_buffer_stack"));
</pre>
 <p>to <code>binding_cluster::mark_as_escaped</code> to trap a point where
<code>yy_buffer_stack</code> was mistakenly being treated as having escaped.

<!-- Copyright (C) 2018-2022 Free Software Foundation, Inc. -->
<!-- Free Software Foundation, Inc. -->
<!-- This is part of the GCC manual. -->
<!-- For copying conditions, see the file gcc.texi. -->
</body></html>

